THREE.OBJLoader=function(e){this.manager=void 0!==e?e:THREE.DefaultLoadingManager},THREE.OBJLoader.prototype={constructor:THREE.OBJLoader,load:function(e,_,s,t){var r=this,d=new THREE.XHRLoader(r.manager);d.setCrossOrigin(this.crossOrigin),d.load(e,function(e){_(r.parse(e))})},parse:function(e){function _(e,_,s){return new THREE.Vector3(e,_,s)}function s(e,_){return new THREE.Vector2(e,_)}function t(e,_,s,t){return new THREE.Face3(e,_,s,t)}var r=new THREE.Object3D;!1===/^o /gm.test(e)&&(m=new THREE.Geometry,g=new THREE.MeshLambertMaterial,x=new THREE.Mesh(m,g),r.add(x));for(var d=[],n=0,u=[],a=[],c=/v( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/,h=/vn( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/,i=/vt( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/,o=/f( +\d+)( +\d+)( +\d+)( +\d+)?/,p=/f( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))?/,f=/f( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))?/,l=/f( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))?/,v=e.split("\n"),$=0;$<v.length;$++){var m,g,x,w,V=v[$];0!==(V=V.trim()).length&&"#"!==V.charAt(0)&&(null!==(w=c.exec(V))?d.push(_(parseFloat(w[1]),parseFloat(w[2]),parseFloat(w[3]))):null!==(w=h.exec(V))?u.push(_(parseFloat(w[1]),parseFloat(w[2]),parseFloat(w[3]))):null!==(w=i.exec(V))?a.push(s(parseFloat(w[1]),parseFloat(w[2]))):null!==(w=o.exec(V))?void 0===w[4]?(m.vertices.push(d[parseInt(w[1])-1],d[parseInt(w[2])-1],d[parseInt(w[3])-1]),m.faces.push(t(n++,n++,n++))):(m.vertices.push(d[parseInt(w[1])-1],d[parseInt(w[2])-1],d[parseInt(w[3])-1],d[parseInt(w[4])-1]),m.faces.push(t(n,n+1,n+3)),m.faces.push(t(n+1,n+2,n+3)),n+=4):null!==(w=p.exec(V))?void 0===w[10]?(m.vertices.push(d[parseInt(w[2])-1],d[parseInt(w[5])-1],d[parseInt(w[8])-1]),m.faces.push(t(n++,n++,n++)),m.faceVertexUvs[0].push([a[parseInt(w[3])-1],a[parseInt(w[6])-1],a[parseInt(w[9])-1]])):(m.vertices.push(d[parseInt(w[2])-1],d[parseInt(w[5])-1],d[parseInt(w[8])-1],d[parseInt(w[11])-1]),m.faces.push(t(n,n+1,n+3)),m.faceVertexUvs[0].push([a[parseInt(w[3])-1],a[parseInt(w[6])-1],a[parseInt(w[12])-1]]),m.faces.push(t(n+1,n+2,n+3)),m.faceVertexUvs[0].push([a[parseInt(w[6])-1],a[parseInt(w[9])-1],a[parseInt(w[12])-1]]),n+=4):null!==(w=f.exec(V))?void 0===w[13]?(m.vertices.push(d[parseInt(w[2])-1],d[parseInt(w[6])-1],d[parseInt(w[10])-1]),m.faces.push(t(n++,n++,n++,[u[parseInt(w[4])-1],u[parseInt(w[8])-1],u[parseInt(w[12])-1]])),m.faceVertexUvs[0].push([a[parseInt(w[3])-1],a[parseInt(w[7])-1],a[parseInt(w[11])-1]])):(m.vertices.push(d[parseInt(w[2])-1],d[parseInt(w[6])-1],d[parseInt(w[10])-1],d[parseInt(w[14])-1]),m.faces.push(t(n,n+1,n+3,[u[parseInt(w[4])-1],u[parseInt(w[8])-1],u[parseInt(w[16])-1]])),m.faceVertexUvs[0].push([a[parseInt(w[3])-1],a[parseInt(w[7])-1],a[parseInt(w[15])-1]]),m.faces.push(t(n+1,n+2,n+3,[u[parseInt(w[8])-1],u[parseInt(w[12])-1],u[parseInt(w[16])-1]])),m.faceVertexUvs[0].push([a[parseInt(w[7])-1],a[parseInt(w[11])-1],a[parseInt(w[15])-1]]),n+=4):null!==(w=l.exec(V))?void 0===w[10]?(m.vertices.push(d[parseInt(w[2])-1],d[parseInt(w[5])-1],d[parseInt(w[8])-1]),m.faces.push(t(n++,n++,n++,[u[parseInt(w[3])-1],u[parseInt(w[6])-1],u[parseInt(w[9])-1]]))):(m.vertices.push(d[parseInt(w[2])-1],d[parseInt(w[5])-1],d[parseInt(w[8])-1],d[parseInt(w[11])-1]),m.faces.push(t(n,n+1,n+3,[u[parseInt(w[3])-1],u[parseInt(w[6])-1],u[parseInt(w[12])-1]])),m.faces.push(t(n+1,n+2,n+3,[u[parseInt(w[6])-1],u[parseInt(w[9])-1],u[parseInt(w[12])-1]])),n+=4):/^o /.test(V)?(m=new THREE.Geometry,g=new THREE.MeshLambertMaterial,(x=new THREE.Mesh(m,g)).name=V.substring(2).trim(),r.add(x),n=0):/^g /.test(V)||(/^usemtl /.test(V)?g.name=V.substring(7).trim():/^mtllib /.test(V)||/^s /.test(V)))}for(var $=0,L=r.children.length;$<L;$++){var m=r.children[$].geometry;m.computeCentroids(),m.computeFaceNormals(),m.computeBoundingSphere()}return r}};